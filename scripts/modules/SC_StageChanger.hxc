import funkin.data.stage.StageRegistry;
import funkin.graphics.FunkinSprite;
import funkin.play.PlayState;
import funkin.play.stage.Stage;
import funkin.play.character.CharacterDataParser;
import funkin.play.character.CharacterType;
import funkin.modding.events.ScriptEvent;
import funkin.modding.events.ScriptEventDispatcher;
import funkin.modding.module.Module;
import haxe.ds.StringMap;
import StringTools;

/**
 * The main module that handles stage changing!
 * This comes with the added benefit of preloading all of the stage props.
 */
class SC_StageChanger extends Module
{
  function new()
  {
    super('SC_StageChanger');
  }

  /**
   * Preload all of the stage props to reduce lag when a stage is loaded.
   */
  function onSongLoaded(event:SongLoadScriptEvent):Void
  {
    var stageIDMap:StringMap<String> = new StringMap();

    for (event in event.events)
    {
      if (event.eventKind == 'ChangeStage')
      {
        var stageID = event.value.stageid;
        if (stageID != null && stageID != '')
        {
          stageIDMap.set(stageID, stageID);
        }
      }
    }

    for (stageID in stageIDMap.keys())
    {
      trace('Preloading stage props for: ' + stageID);
      var stageData:Stage = Stage._fetchData(stageID);
      for (prop in stageData.props)
      {
        if (StringTools.startsWith(prop.assetPath, '#'))
        {
          continue;
        }
        trace('Caching texture for prop: ' + prop.assetPath);
        FunkinSprite.cacheTexture(Paths.image(prop.assetPath, stageData.directory ?? ''));
      }
    }
  }

  /**
   * Changes the stage.
   * @param stageID The ID of the stage to load.
   * @param characters Optional. If provided, the characters to load.
   */
  function swapStage(stageID:String = 'mainStage', ?characters:Array<String> = null):Void
  {
    if (PlayState.instance == null || PlayState.instance.currentStage == null) return;
    if (PlayState.instance.isMinimalMode) return;

    characters = [
      characters != null ? characters[0] : PlayState.instance.currentStage.getBoyfriend()?.characterId,
      characters != null ? characters[1] : PlayState.instance.currentStage.getGirlfriend()?.characterId,
      characters != null ? characters[2] : PlayState.instance.currentStage.getDad()?.characterId
    ];

    loadStage(stageID);

    var bf:BaseCharacter = CharacterDataParser.fetchCharacter(characters[0]);
    var gf:BaseCharacter = CharacterDataParser.fetchCharacter(characters[1]);
    var dad:BaseCharacter = CharacterDataParser.fetchCharacter(characters[2]);

    if (bf != null)
    {
      bf.initHealthIcon(true);
      if (PlayState.instance.currentStage.getBoyfriend() != null)
      {
        PlayState.instance.currentStage.getBoyfriend().destroy();
      }
      PlayState.instance.currentStage.addCharacter(bf, CharacterType.BF);
    }

    if (gf != null)
    {
      if (PlayState.instance.currentStage.getGirlfriend() != null)
      {
        PlayState.instance.currentStage.getGirlfriend().destroy();
      }
      PlayState.instance.currentStage.addCharacter(gf, CharacterType.GF);
    }

    if (dad != null)
    {
      dad.initHealthIcon(true);
      if (PlayState.instance.currentStage.getDad() != null)
      {
        PlayState.instance.currentStage.getDad().destroy();
      }
      PlayState.instance.currentStage.addCharacter(dad, CharacterType.DAD);
    }
    PlayState.instance.currentStage.resetStage();
    PlayState.instance.currentStage.refresh();
  }

  /**
   * Loads a stage by ID and removes the current stage.
   * @param id The ID of the stage to load.
   */
  function loadStage(id:String):Void
  {
    PlayState.instance.remove(PlayState.instance.currentStage);
    PlayState.instance.currentStage.kill();
    for (sprite in PlayState.instance.currentStage.group)
    {
      if (sprite != null)
      {
        sprite.kill();
        PlayState.instance.currentStage.group.remove(sprite);
      }
    }
    PlayState.instance.currentStage = null;

    PlayState.instance.currentStage = StageRegistry.instance.fetchEntry(id);

    if (PlayState.instance.currentStage != null)
    {
      stageDirectory = PlayState.instance.currentStage?._data?.directory ?? "shared";
      Paths.setCurrentLevel(stageDirectory);

      PlayState.instance.currentStage.revive();

      PlayState.instance.resetCameraZoom();

      PlayState.instance.currentStage.buildStage();
      PlayState.instance.currentStage.resetStage();
      PlayState.instance.add(PlayState.instance.currentStage);
    }
  }

  /**
   * Reset the stage back to default when the song is restarted.
   */
  override function onCountdownStart(event:CountdownScriptEvent):Void
  {
    if (PlayState.instance.currentStage.id != PlayState.instance.currentChart.stage)
    {
      resetStage();
    }
  }

  /**
   * Resets the stage to the original state.
   * This is called when the song is restarted.
   */
  function resetStage():Void
  {
    swapStage(PlayState.instance.currentChart.stage, [
      PlayState.instance.currentChart.characters.player,
      PlayState.instance.currentChart.characters.girlfriend,
      PlayState.instance.currentChart.characters.opponent
    ]);
  }
}
